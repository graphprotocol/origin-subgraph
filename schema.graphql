# EVENTS - ListingCreated, ListingUpdated, ListingWithdrawn, ListingArbitrated,
type Listing @entity {
    id: ID!
    blockNumber: BigInt!
    seller: Bytes!
    depositManager: Bytes!
    deposit: BigInt!

    # used because the current withdraw and disputeschemas have no required fields, and can simply be recorded by the fact the event was
    #emitted, and no need to read the IPFS data, since it will all be the same hash
    status: String! # created, updated, withdrawn, disputed
    offers: [Offer!]! @derivedFrom(field: "listingID")
    # Records the single events that can be emitted as extra, and effect no storage
    listingExtraData: [ListingExtraData!]! @derivedFrom(field: "listingID")
    extraDataCount: Int! # used to derive a relation to the ListingExtraData

    # Below are data grabbed from IPFS
    price: String
    currency: String
    commissionAmount: String
    commissionCurrency: String
    commissionPerUnit: String
    commissionPerUnitCurrency: String
    schemaId: String!
    listingType: String!
    category: String!
    subCategory: String!
    language: String!
    title: String!
    description: String!
    unitsTotal: BigInt!
    dappSchemaId: String
    media: [Media!]! @derivedFrom(field: "listingID")
}

type Media @entity {
    id: ID! # the IPFS Hash, concatenated with the location in the array
    url: String!
    contentType: String!
    listingID: String!
}

# Extra data that is emitted as an event, not stored on ethereum
# Note - not emitted on mainnet yet, so can't test
type ListingExtraData @entity {
    id: ID!
    listingID: String!
    sender: Bytes!
    ipfsHashBytes: Bytes!
    ipfsHashBase58: String!
}

# EVENTS - OfferCreated, OfferAccepted, OfferFinalized, OfferWithdrawn, OfferFundsAdded, OfferDisputed, OfferRuling, OfferData
type Offer @entity {
    id: ID!             # a concatenation of the listing ID and the Offer location in the Offer[]
    listingID: String!
    blockNumber: BigInt!

    # required values, from contract storage
    value: BigInt!          # amount in eth or ERC20 token
    commission: BigInt!
    refund: BigInt!
#    currency: Bytes!       # currency of listing - Can't grab from the storage
    buyer: Bytes!           # as in the person offering to buy
    affiliate: Bytes!       # address to send any commission
    arbitrator: Bytes!      # address that settles disputes
    finalizes: BigInt       # According to origin docs, this isnt a required field
    status: Int!            # 0 = undefined, 1 = created, 2 = accepted, 3 = disputed. 4 = finalized, 5 = withdrawn (4 and 5 are supersets of whats in the smart contract)

    # optional from the schema
    review: Review
    disputer: String        # extra field, so we can store if buyer or seller started dispute
    ruling: BigInt          # only set if it gets ruled - 0: Seller, 1: Buyer, 2: Com + Seller, 3: Com + Buyer

    # Below are data grabbed from IPFS
    # removed listingID here , it is a duplicate
    schemaId: String!
    listingType: String!
    unitsPurchased: BigInt!
    price: String
    currency: String
    commissionPrice: String
    commissionCurrency: String

    # Records the single events that can be emitted as extra, and effect no storage
    offerExtraData: [OfferExtraData!]! @derivedFrom(field: "offerID")
    extraDataCount: Int!  # used to derive a relation to the ListingExtraData
}
# Review made when OfferFinalized is emitted. The Review is stored in ipfs
type Review @entity {
    id: ID!             # the IPFS hash
    blockNumber: BigInt!
    schemaId: String!
    rating: Int!        # rating 0-5
    text: String!       # review text
}

# Extra data that is emitted as an event, not stored in contract
type OfferExtraData @entity {
    id: ID!
    offerID: String!
    sender: Bytes!
    ipfsHashBytes: Bytes!
    ipfsHashBase58: String!
}

type User @entity {
    id: ID!
    listings: [Listing!]! @derivedFrom(field: "seller")
    offers: [Offer!]! @derivedFrom(field: "buyer")
}

# might need, would be a list of addresses, that are valid, and a placeholder ID
# EVENTS - AffiliateAdded, AffiliateRemoved
type AllowedAffiliate @entity {
    id: ID!
    affiliates: [Bytes!]!
    ipfsHash: [Bytes!]!
}

# Just additional data that can be emitted by the marketplace contract, not stored in contract
# EVENT - MarketplaceData
type MarketplaceData @entity {
    id: ID! #ipfs hash
    party: Bytes!
}