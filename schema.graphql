# EVENTS - ListingCreated, ListingUpdated, ListingWithdrawn, ListingArbitrated,
type Listing @entity {
    id: ID!
    blockNumber: BigInt!
    seller: Bytes!
    depositManager: Bytes!
    deposit: BigInt!
    ipfsBytesHashes: [Bytes!]! # multiple, from updates
    ipfsBase58Hashes: [String!]!
    offers: [Offer!]! @derivedFrom(field: "listingID")
    ipfsData: [IPFSListingData!]! @derivedFrom(field: "listingID")

    # Records the single events that can be emitted as extra, and effect no storage
    listingExtraData: [ListingExtraData!]! @derivedFrom(field: "listingID")

    # used because the current withdraw and dispute
    # schemas have no required fields, and can simply be recorded by the fact the event was
    # emitted, and no need to read the IPFS data, since it will all be the same hash
    status: String! # created, updated, withdrawn, disputed

}

# From IPFS, not stored on ethereum
# Note that a user can (and it is shown when querying send two different listings, with the
# exact same data, which will result in a listing that shares the IPFSListingData. This is okau
# It will end up overwriting it in the subgraph, but that is fine because it is the exact same
# The listingID will get overwritten, making it only derivatily relational to the lastest listing
type IPFSListingData @entity {
    id: ID!              # the IPFS hash
    listingID: String!   # used to derive the relationship
    blockNumber: BigInt! # helps with identifying Listing Updates, among other things

    # Required Fields
    schemaId: String!
    listingType: String!
    category: String!
    subCategory: String!
    language: String!
    title: String!
    description: String!
    unitsTotal: BigInt!
    price: IPFSListingCurrency!

    # Optional Fields
    commission: IPFSListingCommission
    commissionPerUnit: IPFSListingCommissionPerUnit
    dappSchemaId: String
    media: [Media!]! @derivedFrom(field: "listing")
}

    type IPFSListingCurrency @entity {
        id: ID! # the IPFS Hash
        amount: String!
        currency: String!
    }

    type IPFSListingCommission @entity {
        id: ID! # the IPFS Hash
        amount: String!
        currency: String!
    }

    type IPFSListingCommissionPerUnit @entity {
        id: ID! # the IPFS Hash
        amount: String!
        currency: String!
    }

    type Media @entity {
        id: ID!                 # the IPFS Hash, concatenated with the location in the array
        url: String!
        contentType: String!
        listing: String!
    }

    # Extra data that is emitted as an event, not stored on ethereum
    # Note - not emitted on mainnet yet, so can't test
    type ListingExtraData @entity {
        id: ID!
        listingID: String!
        sender: Bytes!
        ipfsHashBytes: Bytes!
        ipfsHashBase58: String!
    }

# EVENTS - OfferCreated, OfferAccepted, OfferFinalized, OfferWithdrawn, OfferFundsAdded, OfferDisputed, OfferRuling, OfferData
type Offer @entity {
    id: ID!             # most likely a concatenation of the listing ID and the Offer location in the Offer[]
    listingID: String!

    value: BigInt!      # amount in eth or ERC20 token
    commission: BigInt! #
    refund: BigInt!     #
    currency: Bytes!    # currency of listing
    buyer: Bytes!       # as in the person offering to buy
    affiliate: Bytes!   # address to send any commission
    arbitrator: Bytes!  # address that settles disputes
    finalizes: BigInt!  #
    # to add, open, withdrawn, finalized, disputeRuled, and make string? to see
    status: Int!        # 0 = undefined, 1 = created, 2 = accepted, 3 = disputed

    disputer: String    # extra field, so we can store if buyer or seller started dispute
    ruling: BigInt      # only set if it gets ruled - 0: Seller, 1: Buyer, 2: Com + Seller, 3: Com + Buyer

    ipfsHashesBytes: [Bytes!]!
    ipfsHashesBase58: [String!]!

    ipfsData: [IPFSOfferData!]! @derivedFrom(field: "offerID")
    offerExtraData: [OfferExtraData!]! @derivedFrom(field: "offerID")
}

# From IPFS, not on the contract
type IPFSOfferData @entity {
    id: ID!
    offerID: String!
    blockNumber: BigInt!

    listingId: String       # According to origin docs, this isnt a required field
    schemaId: String!
    listingType: String!
    unitsPurchased: BigInt!
    finalizes: BigInt       # According to origin docs, this isnt a required field

    totalPrice: IPFSOfferTotalPrice!
    commission: IPFSOfferCommission!     # Note - origin states this is an unsafe field
}

    type IPFSOfferTotalPrice @entity {
        id: ID! # the IPFS Hash
        amount: String!
        currency: String!
    }

    type IPFSOfferCommission @entity {
        id: ID! # the IPFS Hash
        amount: String!
        currency: String!
    }


    # Extra data that is emitted as an event, not stored on ethereum
    type OfferExtraData @entity {
        id: ID!
        offerID: String!
        sender: Bytes!
        ipfsHashBytes: Bytes!
        ipfsHashBase58: String!
    }

type User @entity {
    id: ID!

    # TODO
}

# might need, would be a list of addresses, that are valid, and a placeholder ID
# EVENTS - AffiliateAdded, AffiliateRemoved
type AllowedAffiliate @entity {
    id: ID!
    affiliates: [Bytes!]!
    ipfsHash: [Bytes!]!
}

# Just additional data that can be emitted by the marketplace contract, not stored in contract
# EVENTS - MarketplaceData
type MarketplaceData @entity {
    id: ID! #ipfs hash
    party: Bytes!
}


# it appears a claim can be valid or invalid, but that an entire claim is its own address. kinda what yaniv was talked about.
# this would probably make the ClaimVerifer a single address on mainnet, and the claims Multi-address
# also note, the Claim Verifer has no account storage, it just emits events that a claim is Valid

# EVENTS -
# do we need:
# event IdentityUpdated, IdentityDeleted

## events ClaimAdded, ClaimRemoved , ClaimValid, ClaimInvalid
#type Claim @entity {
#    id: ID!             # claimID, used to store them in a mapping
#    topic: BigInt!      # number representing topic of claim (biometric, residence, etc)
#    scheme: BigInt!     # scheme with which this claim SHOULD be verified. or ECDSA, RSA, etc
#    issuer: Bytes!      # The issuers identity contract address, or the addr used to sign signature
#    signature: Bytes!   # proof that the claim issuer issued a claim of topic for this identity
#    data: Bytes!        # the hash of the claim data, sitting in another location
#    uri: String!        # the location of the claim (IPFS)
#    claimValid: Boolean #
#}
#
## a proxy contact for key management and execution
#type KeyHolderData @entity {
#    id: ID! # i think each key is its own contract address, thus making this a contract address
#    executionNone: BigInt!
#    keys: [Bytes32!]! # TODO - might be wrong
#    executions: [Executions!]!
#}
#
#type Key @entity {
#    id: ID! # key
#    keyType: BigInt!
#    purposes: [BigInt!]!
#}
#
#type Execution @entity {
#
#}
